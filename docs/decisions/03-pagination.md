# 페이지네이션 피쳐 의사결정 문서

## 개요

페이지네이션 피쳐 구현을 위한 의사결정을 기록합니다.

---

## 결정 1: 페이지네이션 UI 형태

**날짜**: 2025-12-12

### 컨텍스트

페이지네이션 피쳐의 사용자 경험을 정의하기 위해 UI 형태를 결정해야 함. 사용성 관점에서 필수 요소와 선택 요소를 구분하여 결정해야 함

### 결정

**기본 페이지네이션 UI 구성**

**필수 요소:**

- 페이지 번호 버튼 (현재 페이지 하이라이트, 클릭 가능)
- 이전/다음 버튼 (첫/마지막 페이지에서 비활성화)

**선택 요소 (초기 구현 제외):**

- 첫 페이지/마지막 페이지 이동 버튼
- 페이지 번호 직접 입력
- 페이지 번호 표시 범위 제한 (현재 ±N개만 표시)

### 근거

- **사용성**: 페이지 번호와 이전/다음 버튼만으로도 기본적인 페이지네이션 기능 제공 가능
- **단순성**: 초기 구현은 필수 요소만으로 단순하게 시작
- **확장성**: 필요 시 선택 요소 추가 가능
- **표준 패턴**: 대부분의 페이지네이션 UI에서 제공하는 기본 구성

### 코드 위치

- 페이지네이션 컴포넌트: `src/app/(features)/list-pagination/components/Pagination.tsx`

---

## 결정 2: 사용자 경험 및 접근성

**날짜**: 2025-12-12

### 컨텍스트

페이지네이션 피쳐의 사용자 경험을 최적화하고 접근성을 고려한 결정이 필요함. 사용자가 페이지네이션을 사용할 때 겪을 수 있는 문제와 기대하는 동작을 고려해야 함

### 결정

**사용자 중심 설계 원칙 적용**

1. **페이지 상태 유지: URL 쿼리 파라미터 사용**
   - URL에 `?page=1` 형태로 페이지 상태 저장
   - 북마크/공유 가능
   - 뒤로가기 시 이전 페이지로 복귀
   - 새로고침 시 현재 페이지 유지

   **근거:**
   - 북마크, 공유, 뒤로가기 등 기본적인 브라우저 기능 활용 가능
   - 사용자가 원하는 페이지를 북마크하거나 공유할 수 있음

   **대안 검토:**
   - **로컬 상태만 사용**: 구현이 단순하지만 북마크/공유 불가능, 새로고침 시 첫 페이지로 이동, 뒤로가기 동작 불가능
   - **선택하지 않은 이유**: 사용자 경험 측면에서 URL 쿼리 파라미터가 훨씬 유리함

2. **데이터 변경 시 동작: 자동 이전 페이지 이동**
   - 현재 페이지에 데이터가 없을 때 (예: 마지막 페이지에서 삭제)
   - 자동으로 이전 페이지로 이동
   - 빈 페이지 표시 방지

   **근거:**
   - 데이터 변경 시에도 사용자가 혼란스럽지 않도록 처리
   - 빈 화면을 보지 않도록 자연스러운 동작

   **대안 검토:**
   - **빈 페이지 표시**: 구현이 단순하지만 사용자가 혼란스러움, 빈 화면을 보게 됨
   - **선택하지 않은 이유**: 사용자 경험을 해침, 자동으로 이전 페이지로 이동하는 것이 자연스러움

3. **페이지 이동 시 피드백: 이전 데이터 유지** (Transition 활용)
   - **Transition 상태(`isPending`) 활용**: `useTransition` 훅을 명시적으로 사용하여 **`isPending` 상태**를 확보합니다. 데이터 로딩 완료 시점까지 스켈레톤 대신 **이전 화면을 유지**하도록 UI 전환을 지연(Delay)시킵니다.
   - **시각적 피드백 제공**: 로딩 중(`isPending: true`)일 때, 리스트 컨테이너의 **투명도(Opacity)를 조절**하여 시각적 피드백을 제공합니다.

   **근거:**
   - **UX 안정성**: 데이터 로딩 지연 시 발생하는 화면 멈춤 현상을 해소하고, 사용자에게 명확한 '진행 중' 상태 피드백을 제공합니다.
   - **고급스러운 전환**: 스켈레톤의 깜빡임 없이 완성된 이전 화면에서 다음 화면으로 부드럽게 전환되는 **안정적인 UX**를 보장합니다.

   **대안 검토:**
   - **스켈레톤 즉시 노출 (key 변경)**: `key` props를 변경하여 컴포넌트를 강제 재렌더링하고 스켈레톤을 노출.
   - **선택하지 않은 이유**: 페이지 이동 시 스켈레톤이 계속 깜빡이는 현상(Flickering)을 유발하여 시각적 피로감을 증가시키므로 제외함.

4. **접근성: 키보드 네비게이션 및 스크린 리더 지원**
   - Tab 키로 페이지네이션 버튼 이동 가능
   - Enter/Space로 페이지 이동
   - 스크린 리더를 위한 aria-label 제공
   - 현재 페이지에 aria-current="page" 속성

   **근거:**
   - 모든 사용자가 페이지네이션을 사용할 수 있도록 보장
   - 웹 접근성 표준 준수

5. **에러 처리 및 피드백**
   - API 에러 발생 시: 명확한 에러 메시지 표시, 페이지네이션 버튼 비활성화
   - 네트워크 에러: 재시도 기능 제공
   - 잘못된 페이지 접근: 존재하지 않는 페이지 번호 접근 시 유효한 페이지로 자동 이동
   - 사용자 피드백: 에러 상황을 명확히 전달하고 재시도 가능하도록 제공

   **근거:**
   - 에러 발생 시에도 사용자가 혼란스럽지 않도록 명확한 피드백 제공
   - 재시도 기능으로 사용자가 직접 해결할 수 있는 기회 제공

   **대안 검토:**
   - **에러 숨김**: 구현이 단순하지만 사용자가 에러 상황을 인지하지 못함
   - **재시도 없음**: 구현이 단순하지만 사용자가 직접 해결할 방법이 없음
   - **선택하지 않은 이유**: 사용자 경험을 해침, 명확한 피드백과 재시도 기능이 필수적

---

## 결정 3: 페이지네이션 방식 선택

**날짜**: 2025-12-12

### 컨텍스트

페이지네이션 피쳐를 구현하기 위해 어떤 페이지네이션 방식을 사용할지 결정해야 함. 페이지 번호를 표시하고 특정 페이지로 이동할 수 있는 전통적인 페이지네이션 UI를 구현해야 함

### 결정

**Page-based 방식 (page, limit) 선택**

- **API 파라미터**: `page`, `limit`
- **예시**: `GET /api/posts?page=1&limit=10`
- **페이지 번호**: 1부터 시작

### 근거

- **직관성**: 페이지 번호와 API 파라미터가 직접 매핑되어 직관적
- **프론트엔드 구현 단순**: page 상태가 UI와 직접 연결되어 구현이 단순함
- **UI 표시 용이**: "1페이지, 2페이지" 형태로 자연스럽게 표시 가능
- **전체 페이지 수 계산 단순**: `totalPages = Math.ceil(total / limit)`로 간단히 계산 가능
- **사용자 경험**: 사용자가 원하는 페이지 번호로 바로 이동 가능

### API 구조

**요청:**

```
GET /api/posts?page=1&limit=10
```

**응답:**

```typescript
interface PaginationMeta {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

interface PaginatedResponse<T> {
  data: T[];
  meta: PaginationMeta;
}
```

### 프론트엔드 구현 예시

```typescript
// 상태 관리
const [page, setPage] = useState(1);
const limit = 10;

// API 호출
const { data } = useQuery({
  queryKey: ['posts', page],
  queryFn: () => getPosts({ page, limit }),
});

// 페이지 이동
const goToPage = (newPage: number) => {
  setPage(newPage);
};

// 전체 페이지 수
const totalPages = data.meta.totalPages;
```

### 대안 검토

#### 대안 1: Offset-based 방식 (offset, limit)

**특징:**

- API 파라미터: `offset`, `limit`
- 예시: `GET /api/posts?offset=0&limit=10`

**장점:**

- 서버 구현이 단순 (offset을 그대로 사용)
- 더 유연함 (임의의 offset 지정 가능)

**단점:**

- 페이지 번호로 변환 필요 (`page = offset / limit + 1`)
- 전체 페이지 수 계산 시 추가 로직 필요
- UI 표시가 덜 직관적 ("offset 0, offset 10" vs "1페이지, 2페이지")
- offset이 클수록 성능 저하 (OFFSET이 크면 DB 부하)
- 프론트엔드에서 page → offset 변환 로직 필요

**선택하지 않은 이유:**

- 페이지네이션 UI에서는 페이지 번호가 핵심인데, offset은 이를 직접 표현하지 못함
- 프론트엔드 구현이 더 복잡해짐
- Page-based가 페이지네이션 목적에 더 적합

### 서버 구현 참고

서버에서는 page를 offset으로 변환하여 사용:

```typescript
// 서버에서 page를 offset으로 변환
const offset = (page - 1) * limit;
```

### 코드 위치

- 공통 타입: `src/shared/types/post.ts` (PaginatedResponse, PaginationMeta)
- 피쳐별 API: `src/app/(features)/list-pagination/api/posts.ts`

---

## 결정 4: 페이지네이션 SEO 및 메타데이터 전략

**날짜**: 2025-12-13

### 컨텍스트

페이지네이션으로 분리된 페이지(`?page=1`, `?page=2`)들이 동일한 메타데이터(Title, Description)를 가질 경우, 검색 엔진은 이를 **중복 콘텐츠(Duplicate Content)**로 인식하여 검색 노출 순위에 악영향을 줄 수 있음. 또한, 사용자의 브라우저 방문 기록(History)이나 탭 제목에서 각 페이지가 구분되지 않아 탐색 경험이 저하됨.

### 결정

**Next.js `generateMetadata`를 활용한 서버 사이드 동적 처리**

1.  **동적 타이틀(Dynamic Title) 적용**
    - 쿼리 파라미터(`page`)를 읽어와 `<title>`에 페이지 번호를 명시
    - 형식: `"포스트 목록 (N페이지) | 서비스명"`

    **근거:**
    - 브라우저 탭, 방문 기록에서 사용자가 특정 페이지를 식별할 수 있음
    - 각 페이지가 고유한 제목을 가져 검색 엔진이 독립된 문서로 인식함

2.  **Canonical URL (표준 주소) 명시**
    - `alternates.canonical` 속성에 현재 페이지의 절대 경로와 파라미터를 명시
    - 예: `/list-pagination?page=2`

    **근거:**
    - 파라미터 순서 변경(예: `?limit=10&page=1` vs `?page=1&limit=10`)으로 인한 중복 페이지 집계를 방지
    - 검색 엔진에게 "이 주소가 원본임"을 명확히 전달하여 SEO 점수 분산 방지

3.  **검색 로봇 허용 및 Open Graph 설정**
    - `robots: { index: true, follow: true }` 설정
    - 공유 시 보여질 Open Graph(OG) 태그 동적 생성

    **근거:**
    - 목록 페이지는 사용자와 크롤러의 주요 진입점이므로 인덱싱이 필수적임
    - SNS 공유 시 해당 페이지 번호에 맞는 정확한 정보 전달

### 근거

- **검색 엔진 최적화 (SEO)**: 중복 콘텐츠 페널티를 피하고, 롱테일 키워드(특정 페이지의 콘텐츠) 노출 기회를 높임
- **사용자 경험 (UX)**: "뒤로 가기"나 "방문 기록" 탐색 시, 사용자가 자신이 보던 페이지를 제목만 보고도 찾을 수 있음
- **기술적 적합성**: Next.js App Router는 서버 컴포넌트에서 메타데이터를 생성하여 HTML에 주입해서 내려주므로, 클라이언트 사이드(`useEffect`) 방식보다 크롤러 수집률이 압도적으로 높음

### 대안 검토

#### 대안 1: 정적 메타데이터 (`export const metadata`)

**특징:**

- 모든 페이지가 "게시글 목록"이라는 하나의 제목만 가짐

**단점:**

- 1페이지와 100페이지가 구분되지 않아 검색 엔진이 중복 문서로 처리할 위험이 큼
- 사용자가 브라우저 히스토리에서 특정 페이지를 찾기 어려움

**선택하지 않은 이유:**

- 페이지네이션의 특성상 각 페이지는 서로 다른 콘텐츠를 담고 있으므로, 메타데이터도 그에 맞춰 달라야 한다고 판단함

#### 대안 2: 클라이언트 사이드 처리 (`useEffect` + `document.title`)

**특징:**

- 페이지 렌더링 후 자바스크립트로 타이틀 변경

**단점:**

- 검색 봇(Crawler)이 자바스크립트를 실행하기 전의 HTML만 수집할 경우, 변경된 타이틀을 인식하지 못할 수 있음
- 화면 로딩 후 타이틀이 깜빡이며 바뀌는 현상 발생

**선택하지 않은 이유:**

- SEO가 중요한 목록 페이지이므로, 서버 사이드에서 완벽한 HTML을 내려주는 방식이 필수적임

### 코드 위치

- 페이지 컴포넌트: `src/app/(features)/list-pagination/page.tsx` (`generateMetadata` 함수)
