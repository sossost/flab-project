# 페이지네이션 피쳐 의사결정 문서

## 개요

페이지네이션 피쳐 구현을 위한 의사결정을 기록합니다.

---

## 결정 1: 페이지네이션 UI 형태

**날짜**: 2025-12-12

### 컨텍스트

페이지네이션 피쳐의 사용자 경험을 정의하기 위해 UI 형태를 결정해야 함. 사용성 관점에서 필수 요소와 선택 요소를 구분하여 결정해야 함

### 결정

**기본 페이지네이션 UI 구성**

**필수 요소:**

- 페이지 번호 버튼 (현재 페이지 하이라이트, 클릭 가능)
- 이전/다음 버튼 (첫/마지막 페이지에서 비활성화)

**선택 요소 (초기 구현 제외):**

- 첫 페이지/마지막 페이지 이동 버튼
- 페이지 번호 직접 입력
- 페이지 번호 표시 범위 제한 (현재 ±N개만 표시)

### 근거

- **사용성**: 페이지 번호와 이전/다음 버튼만으로도 기본적인 페이지네이션 기능 제공 가능
- **단순성**: 초기 구현은 필수 요소만으로 단순하게 시작
- **확장성**: 필요 시 선택 요소 추가 가능
- **표준 패턴**: 대부분의 페이지네이션 UI에서 제공하는 기본 구성

### 코드 위치

- 페이지네이션 컴포넌트: `src/app/list-pagination/components/Pagination.tsx`

---

## 결정 2: 사용자 경험 및 접근성

**날짜**: 2025-12-12

### 컨텍스트

페이지네이션 피쳐의 사용자 경험을 최적화하고 접근성을 고려한 결정이 필요함. 사용자가 페이지네이션을 사용할 때 겪을 수 있는 문제와 기대하는 동작을 고려해야 함

### 결정

**사용자 중심 설계 원칙 적용**

1. **페이지 상태 유지: URL 쿼리 파라미터 사용**
   - URL에 `?page=1` 형태로 페이지 상태 저장
   - 북마크/공유 가능
   - 뒤로가기 시 이전 페이지로 복귀
   - 새로고침 시 현재 페이지 유지

   **근거:**
   - 북마크, 공유, 뒤로가기 등 기본적인 브라우저 기능 활용 가능
   - 사용자가 원하는 페이지를 북마크하거나 공유할 수 있음

   **대안 검토:**
   - **로컬 상태만 사용**: 구현이 단순하지만 북마크/공유 불가능, 새로고침 시 첫 페이지로 이동, 뒤로가기 동작 불가능
   - **선택하지 않은 이유**: 사용자 경험 측면에서 URL 쿼리 파라미터가 훨씬 유리함

2. **데이터 변경 시 동작: 자동 이전 페이지 이동**
   - 현재 페이지에 데이터가 없을 때 (예: 마지막 페이지에서 삭제)
   - 자동으로 이전 페이지로 이동
   - 빈 페이지 표시 방지

   **근거:**
   - 데이터 변경 시에도 사용자가 혼란스럽지 않도록 처리
   - 빈 화면을 보지 않도록 자연스러운 동작

   **대안 검토:**
   - **빈 페이지 표시**: 구현이 단순하지만 사용자가 혼란스러움, 빈 화면을 보게 됨
   - **선택하지 않은 이유**: 사용자 경험을 해침, 자동으로 이전 페이지로 이동하는 것이 자연스러움

3. **페이지 이동 시 피드백: 이전 데이터 유지**
   - keepPreviousData 옵션으로 이전 데이터 유지
   - 깜빡임 최소화
   - 로딩 중에도 콘텐츠 표시

   **근거:**
   - 페이지 이동 시 깜빡임 없이 자연스러운 경험
   - 로딩 중에도 콘텐츠가 보여 사용자 경험 향상

4. **현재 위치 인지: 범위 표시**
   - "1-10 / 100" 형태로 현재 범위와 전체 개수 표시
   - 사용자가 전체 중 어느 위치인지 명확히 인지 가능

   **근거:**
   - 사용자가 전체 중 어느 위치에 있는지 항상 알 수 있음
   - 명확한 위치 인지로 사용자 혼란 방지

5. **접근성: 키보드 네비게이션 및 스크린 리더 지원**
   - Tab 키로 페이지네이션 버튼 이동 가능
   - Enter/Space로 페이지 이동
   - 스크린 리더를 위한 aria-label 제공
   - 현재 페이지에 aria-current="page" 속성

   **근거:**
   - 모든 사용자가 페이지네이션을 사용할 수 있도록 보장
   - 웹 접근성 표준 준수

6. **에러 처리 및 피드백**
   - API 에러 발생 시: 명확한 에러 메시지 표시, 페이지네이션 버튼 비활성화
   - 네트워크 에러: 재시도 기능 제공
   - 잘못된 페이지 접근: 존재하지 않는 페이지 번호 접근 시 유효한 페이지로 자동 이동
   - 사용자 피드백: 에러 상황을 명확히 전달하고 재시도 가능하도록 제공

   **근거:**
   - 에러 발생 시에도 사용자가 혼란스럽지 않도록 명확한 피드백 제공
   - 재시도 기능으로 사용자가 직접 해결할 수 있는 기회 제공

   **대안 검토:**
   - **에러 숨김**: 구현이 단순하지만 사용자가 에러 상황을 인지하지 못함
   - **재시도 없음**: 구현이 단순하지만 사용자가 직접 해결할 방법이 없음
   - **선택하지 않은 이유**: 사용자 경험을 해침, 명확한 피드백과 재시도 기능이 필수적

---

## 결정 3: 페이지네이션 방식 선택

**날짜**: 2025-12-12

### 컨텍스트

페이지네이션 피쳐를 구현하기 위해 어떤 페이지네이션 방식을 사용할지 결정해야 함. 페이지 번호를 표시하고 특정 페이지로 이동할 수 있는 전통적인 페이지네이션 UI를 구현해야 함

### 결정

**Page-based 방식 (page, limit) 선택**

- **API 파라미터**: `page`, `limit`
- **예시**: `GET /api/posts?page=1&limit=10`
- **페이지 번호**: 1부터 시작

### 근거

- **직관성**: 페이지 번호와 API 파라미터가 직접 매핑되어 직관적
- **프론트엔드 구현 단순**: page 상태가 UI와 직접 연결되어 구현이 단순함
- **UI 표시 용이**: "1페이지, 2페이지" 형태로 자연스럽게 표시 가능
- **전체 페이지 수 계산 단순**: `totalPages = Math.ceil(total / limit)`로 간단히 계산 가능
- **사용자 경험**: 사용자가 원하는 페이지 번호로 바로 이동 가능

### API 구조

**요청:**

```
GET /api/posts?page=1&limit=10
```

**응답:**

```typescript
interface PaginationMeta {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

interface PaginatedResponse<T> {
  data: T[];
  meta: PaginationMeta;
}
```

### 프론트엔드 구현 예시

```typescript
// 상태 관리
const [page, setPage] = useState(1);
const limit = 10;

// API 호출
const { data } = useQuery({
  queryKey: ['posts', page],
  queryFn: () => getPosts({ page, limit }),
});

// 페이지 이동
const goToPage = (newPage: number) => {
  setPage(newPage);
};

// 전체 페이지 수
const totalPages = data.meta.totalPages;
```

### 대안 검토

#### 대안 1: Offset-based 방식 (offset, limit)

**특징:**

- API 파라미터: `offset`, `limit`
- 예시: `GET /api/posts?offset=0&limit=10`

**장점:**

- 서버 구현이 단순 (offset을 그대로 사용)
- 더 유연함 (임의의 offset 지정 가능)

**단점:**

- 페이지 번호로 변환 필요 (`page = offset / limit + 1`)
- 전체 페이지 수 계산 시 추가 로직 필요
- UI 표시가 덜 직관적 ("offset 0, offset 10" vs "1페이지, 2페이지")
- offset이 클수록 성능 저하 (OFFSET이 크면 DB 부하)
- 프론트엔드에서 page → offset 변환 로직 필요

**선택하지 않은 이유:**

- 페이지네이션 UI에서는 페이지 번호가 핵심인데, offset은 이를 직접 표현하지 못함
- 프론트엔드 구현이 더 복잡해짐
- Page-based가 페이지네이션 목적에 더 적합

### 서버 구현 참고

서버에서는 page를 offset으로 변환하여 사용:

```typescript
// 서버에서 page를 offset으로 변환
const offset = (page - 1) * limit;
```

### 코드 위치

- 공통 타입: `src/shared/types/post.ts` (PaginatedResponse, PaginationMeta)
- 피쳐별 API: `src/app/list-pagination/api/posts.ts`
