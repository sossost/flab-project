# 무한스크롤 피쳐 의사결정 문서

## 개요

무한스크롤 피쳐 구현을 위한 의사결정을 기록합니다.

---

## 결정 1: 자동 로드 트리거 및 하단 UX 패턴

**날짜**: 2025-12-15

### 컨텍스트

무한스크롤 피쳐의 사용자 경험을 정의하기 위해 자동 로드 동작과 하단 UX 패턴을 결정해야 함. 스크롤 기반으로 데이터를 계속 불러오는 특성상, 다음과 같은 요소를 일관된 기준으로 정의해야 함.

- 어느 시점에 자동 로드를 트리거할지
- 로딩 중 상태를 어디에, 어떻게 보여줄지
- 더 이상 불러올 데이터가 없을 때 어떻게 알려줄지
- 에러 발생 시 사용자에게 어떤 피드백과 재시도 수단을 제공할지

### 결정

**IntersectionObserver 기반 자동 로드 + 하단 상태 블록 패턴 사용**

1. **자동 로드 트리거 방식**
   - 리스트 맨 아래에 sentinel 요소(보이지 않는 트리거 박스)를 둠
   - sentinel이 뷰포트에 일정 비율 이상 진입했을 때 다음 페이지를 자동으로 요청함
   - `scrollTop`/`offsetHeight`를 직접 계산하는 `scroll` 이벤트 기반 감지는 사용하지 않음

2. **로딩 상태 표현**
   - 로딩 중에는 리스트 하단에 작은 로딩 인디케이터 표시
   - 이미 로드된 콘텐츠 위를 덮는 풀스크린/오버레이 로딩은 사용하지 않음

3. **데이터 끝(더 이상 없음) 피드백**
   - 더 이상 불러올 데이터가 없을 경우, 하단 로딩 영역을 “마지막입니다” 안내 메시지로 교체함
     - 예: “더 이상 불러올 게시글이 없습니다.”

4. **에러 상태 및 재시도 UX**
   - 초기 로드 에러는 `AsyncBoundary`의 `ErrorBoundary`가 처리함
   - 추가 로드(`fetchNextPage`) 중 에러가 발생하면, 하단 영역을 에러 메시지와 재시도 버튼으로 교체함
   - 이미 화면에 표시된 상단 데이터는 그대로 유지함
   - 사용자는 하단에서 해당 구간만 재시도할 수 있음 (`onLoadMore` 재호출)

5. **스크롤 위치 보존 범위**
   - 리스트에서 아이템 상세 페이지로 이동했다가 뒤로 가기 했을 때, 사용자가 보던 스크롤 위치를 그대로 유지함
   - 추가 로드 과정에서도 스크롤 위치를 인위적으로 변경하지 않아, 이어서 내려보는 흐름을 방해하지 않음

6. **접근성 고려**
   - 하단 로딩 영역은 `role="status"`, `aria-live="polite"` 등을 활용해
     - “더 불러오는 중입니다” 수준의 최소한의 상태 변화를 스크린리더에 전달함
   - 에러/마지막 안내 메시지도 동일한 영역에서 갱신해 시각·비시각 사용자 모두 일관된 피드백을 제공함

### 근거

- **연속 탐색 경험**: 사용자는 스크롤만 하면 자동으로 다음 데이터를 볼 수 있어, 별도 조작 없이 콘텐츠를 이어서 탐색할 수 있음
- **맥락 보존**: 로딩/에러/마지막 상태를 리스트 하단에만 표시하고 스크롤 위치를 인위적으로 변경하지 않아, 사용자가 읽고 있던 위치와 문맥이 끊기지 않음
- **상세 화면 왕복 시 이어보기**: 리스트에서 개별 아이템 상세로 이동했다가 뒤로 가기 했을 때, 이전에 보던 스크롤 위치로 그대로 돌아와 바로 이어서 탐색할 수 있음
- **종료 지점 인지**: “마지막입니다” 메시지로 리스트의 끝을 명확히 알려주어, 사용자가 더 내려야 하는지 고민하지 않고 자연스럽게 탐색을 마무리할 수 있음
- **에러 상황에서도 안정감 유지**: 추가 로드 실패 시에도 이미 보이던 콘텐츠는 그대로 유지되고, 같은 위치에서 재시도할 수 있어 사용자가 “정보를 잃었다”는 느낌을 받지 않음

---

## 결정 2: 스크롤 감지 방식

**날짜**: 2025-12-15

### 컨텍스트

무한스크롤에서는 사용자의 스크롤 위치를 기반으로 다음 데이터를 언제 불러올지 결정해야 함. 이를 위해 하단 근접 여부를 감지하는 방법을 선택해야 함.

- `scroll` 이벤트를 사용해 스크롤 위치를 직접 계산하는 방식
- 브라우저의 `IntersectionObserver` API를 사용하는 방식
- 무한스크롤/Observer 래핑 라이브러리를 사용하는 방식

이번 피쳐는 기본 브라우저 기능과 React를 조합해 동작을 명확하게 이해하는 것을 목표로 하며, 과도한 의존성 추가나 복잡한 수식 기반 구현은 피하고자 함.

### 결정

**브라우저 `IntersectionObserver` API를 사용해 리스트 하단 sentinel 요소를 감지하는 방식으로 구현함**

1. **기본 방식**
   - 윈도우 스크롤 기준(`root: null`, 뷰포트 기준)으로 동작시킴
   - 리스트 맨 아래에 sentinel 요소를 두고, 이 요소가 뷰포트에 일정 비율 이상 진입했을 때 다음 페이지 자동 로드를 트리거함
   - `rootMargin: '0px 0px 200px 0px'`를 설정해 sentinel이 뷰포트 하단에서 200px 위에 있을 때 미리 트리거되도록 함 (사용자가 하단에 도달하기 전에 미리 로드)

2. **사용하지 않는 방식**
   - `window` 또는 컨테이너에 `scroll` 이벤트를 등록해 `scrollTop + clientHeight >= scrollHeight - threshold` 형태로 직접 계산하는 방식은 사용하지 않음
   - 별도의 무한스크롤 전용 라이브러리나 `react-intersection-observer` 등 래핑 라이브러리는 사용하지 않음

### 근거

- **의도 파악이 쉬운 코드**: “sentinel 요소가 화면에 보이면 다음 데이터를 불러온다”라는 모델이 코드 구조에 그대로 드러나, 나중에 봐도 동작 의도를 이해하기 쉬움
- **레이아웃 변경에 강함**: 리스트 높이·컨테이너 구조가 일부 바뀌더라도, sentinel을 하단에 두는 규칙만 지키면 동일한 동작을 유지할 수 있어, 스타일/레이아웃 변경에 덜 민감함
- **불필요한 연산 감소**: 스크롤 이벤트마다 수식을 계산하지 않고, 브라우저가 관찰 대상 요소의 가시성 변화를 적절한 타이밍에 알려주므로, 스크롤이 잦은 환경에서도 체감 성능이 안정적임
- **학습 목적에 부합**: 별도 라이브러리에 동작을 숨기지 않고, 브라우저의 기본 API를 직접 사용함으로써 무한스크롤의 핵심 동작 방식을 명확히 이해할 수 있음

### 대안 검토

- **대안 1: `scroll` 이벤트 기반 수동 계산**
  - 장점: 개념이 단순하고, 추가 API 학습 없이 구현 가능함
  - 단점: 스크롤마다 계속 계산해야 하므로 쓰로틀/디바운스 등 추가 최적화가 필요하고, 레이아웃이 바뀔 때마다 수식을 함께 조정해야 함. 이번 피쳐에서는 유지보수성과 가독성 측면에서 제외함

- **대안 2: 무한스크롤/Observer 래핑 라이브러리 사용**
  - 장점: 코드가 짧고, 옵션 설정만으로 다양한 상황을 처리할 수 있음
  - 단점: 내부 동작을 이해하지 못하면 디버깅이 어려울 수 있고, 이번 과제 스코프에서 굳이 외부 의존성을 추가할 만큼 요구사항이 복잡하지 않음. “브라우저 기본 기능 + React 조합”을 직접 경험하는 목표와도 거리가 있어 제외함

---

## 결정 3: 데이터 페칭 전략 (`useInfiniteQuery`)

**날짜**: 2025-12-15

### 컨텍스트

무한스크롤은 여러 구간의 데이터를 순차적으로 불러와 하나의 리스트처럼 보여줘야 함.  
API와 데이터 모델을 처음 설계한다고 가정했을 때, 다음과 같은 방식 중 어떤 것을 선택할지 결정해야 함.

- **페이지 기반**: `page`, `limit`를 사용해 1, 2, 3… 페이지 단위로 데이터를 조회
- **커서 기반**: `cursor`, `limit`를 사용해 다음 조회 시작점을 커서로 관리
- **오프셋 기반**: `offset`, `limit`를 사용해 시작 인덱스를 기준으로 조회

이번 피쳐는 SNS 피드 수준의 대규모/실시간 데이터가 아니라, 일반적인 게시글 리스트에 가까운 무한스크롤을 구현하는 것이며, 구현 복잡도와 이해 용이성, 실무에서의 사용 빈도를 모두 고려해야 함.

### 결정

**페이지 기반(`page`, `limit`) API를 정의하고, React Query `useInfiniteQuery`로 페이지 단위 데이터를 관리함**

1. **페이지 파라미터**
   - `useSuspenseInfiniteQuery`의 `pageParam`을 정수 페이지 번호로 사용함
   - 첫 페이지는 `initialPageParam: 1`로 시작하고, 이후 페이지는 `getNextPageParam`에서 `page + 1` 방식으로 증가시킴

2. **다음 페이지 여부 판단**
   - `getNextPageParam`에서 마지막 페이지의 `meta` 값을 참고해 `currentPage < totalPages`인 경우에만 다음 페이지를 로드함
   - 더 이상 로드할 페이지가 없을 경우 `undefined`를 반환해 추가 요청을 중단함

3. **데이터 병합 방식**
   - 각 페이지 응답의 `data` 배열을 그대로 유지하고, UI 레벨에서 `pages.flatMap((page) => page.data)` 형태로 평탄화해 렌더링함
   - 기존 페이지네이션 API 응답 구조(`data`, `meta`)를 그대로 사용해 백엔드/타입 정의를 중복으로 만들지 않음

4. **로딩/에러 상태 사용**
   - 초기 로딩은 `AsyncBoundary`의 `Suspense`가 처리하고, 추가 로딩은 `isFetchingNextPage`를 사용해 하단 로딩 인디케이터와 연결함
   - 추가 로드 실패 시 `isError` 상태를 확인해 하단에 재시도 버튼을 표시하고, 사용자가 클릭하면 `fetchNextPage`를 재호출함

### 근거

- **일반적인 리스트 서비스에 적합**: 게시판/블로그/상품 목록 등 많은 서비스가 여전히 `page`, `limit` 기반 페이징을 사용하며, 이번 피쳐도 유사한 규모와 특성을 가지므로 과도한 커서 기반 설계가 필요하지 않음
- **API/UX 매핑이 직관적**: 페이지 번호 개념이 있어 “마지막 페이지입니다”와 같은 끝 표시 UX를 설계·이해하기 쉽고, 무한스크롤 하단의 “마지막입니다” 메시지와 자연스럽게 연결됨
- **무한스크롤에 특화된 상태 모델**: `useInfiniteQuery`는 페이지별 데이터를 배열로 관리하고, 추가 페이지 로드/종료 여부를 내장 상태로 제공해, 수동으로 페이지 배열과 인덱스를 관리하는 코드보다 명확함
- **로딩 단계 구분**: 초기 로딩과 추가 로딩 상태가 분리되어 있어, 첫 진입 시 스켈레톤/로딩과 하단 추가 로딩 인디케이터를 각각 다른 UX로 표현할 수 있음
- **에러 처리 단순화**: 페이지별 로드 에러를 동일한 패턴(`fetchNextPage` 재호출)으로 처리할 수 있어, 하단 에러 블록 + 재시도 버튼 UX와 자연스럽게 맞물림

### 대안 검토

- **대안 1: 커서 기반(`cursor`, `limit`) + `useInfiniteQuery`**
  - 장점: 데이터가 자주 추가/삭제되고 양이 매우 많은 서비스(SNS 피드, 활동 로그 등)에 적합하며, 중간 변동에도 다음 페이지 경계가 안정적으로 유지됨
  - 단점: 커서를 생성·검증하는 백엔드 로직 설계가 필요해 복잡도가 증가함. 이번 피쳐는 비교적 단순한 게시글 리스트를 다루고 있어, 커서 기반 설계의 이점이 충분히 드러나지 않아 제외함

- **대안 2: 오프셋 기반(`offset`, `limit`) + `useInfiniteQuery`**
  - 장점: 데이터 저장소(SQL 등)와의 매핑이 직관적이고, 구현이 단순함
  - 단점: 중간 삽입/삭제가 발생하면 오프셋 기준이 쉽게 틀어져, 긴 리스트에서 “이어보기” 경험을 해치기 쉬움. 무한스크롤에서 스크롤 위치 보존과 조합하기에 적합하지 않아 제외함

- **대안 3: `useQuery` + 수동 페이지 상태 관리**
  - 장점: API 사용이 단순하고, 기본 패턴만 보면 이해하기 쉬움
  - 단점: 무한스크롤에서는 여러 페이지를 동시에 메모리에 올려야 하므로, 각 페이지 데이터와 현재 페이지, 다음 페이지 여부 등을 모두 직접 상태로 관리해야 함. 로딩/에러/종료 상태를 일관되게 처리하기 어렵고, 코드 복잡도가 불필요하게 증가해 제외함

- **대안 4: 로컬 상태 + 직접 fetch 구현**
  - 장점: React Query에 대한 의존 없이, 필요한 데이터만 최소한으로 관리할 수 있음
  - 단점: 캐싱, 중복 요청 방지, 에러/로딩 상태 관리 등을 모두 직접 구현해야 하며, 이미 프로젝트에서 React Query를 사용 중인 상황과도 맞지 않음. 학습/유지보수 측면에서 이점이 크지 않아 제외함

---

## 결정 4: 스크롤 기준 및 레이아웃 구조

**날짜**: 2025-12-15

### 컨텍스트

무한스크롤 피쳐는 `(features)` 레이아웃 아래에서 동작하며, 상단에 고정 헤더가 있고 그 아래 메인 영역이 전체 페이지를 스크롤하는 구조를 사용함.  
이때 스크롤 기준을 **윈도우 전체 스크롤**로 할지, 별도의 내부 스크롤 컨테이너를 둘지 결정해야 함.

선택지는 다음과 같음.

- 윈도우 전체 스크롤 기준으로, 페이지 전체가 하나의 스크롤 컨텍스트를 사용
- 고정 높이의 내부 스크롤 컨테이너를 두고, 그 안에서만 스크롤/무한스크롤 동작

### 결정

**윈도우 전체 스크롤 기준을 사용하고, `(features)` 레이아웃의 메인 영역을 스크롤 컨텍스트로 사용함**

1. **레이아웃 구조**
   - `src/app/(features)/layout.tsx`에서 상단 고정 헤더와 메인 영역을 정의함
   - 메인 영역은 `max-width`와 `margin: 0 auto`를 적용해 중앙 정렬하고, `flex: 1`로 세로 공간을 채움
   - 무한스크롤 페이지(`list-infinite`)는 이 메인 영역 안에서 자연스럽게 아래로 확장됨

2. **스크롤 기준**
   - 별도의 내부 스크롤 컨테이너를 만들지 않고, 브라우저 기본 스크롤(윈도우 스크롤)을 사용함
   - IntersectionObserver의 `root`는 기본값(뷰포트)을 사용하고, sentinel는 리스트 하단에 배치함

### 근거

- **예상 가능한 스크롤 경험**: 페이지 전체가 하나의 스크롤 컨텍스트를 사용하므로, 사용자가 브라우저 기본 스크롤 동작에 익숙한 방식으로 리스트를 탐색할 수 있음
- **레이아웃 단순성**: 내부 스크롤 컨테이너를 추가하지 않아, 스크롤바가 두 개 생기거나 모바일에서 스크롤이 먹지 않는 구간이 생기는 등 혼란스러운 상황을 피할 수 있음
- **기존 레이아웃 재사용**: 이미 `(features)` 레이아웃에서 상단 고정 헤더와 메인 영역을 정의하고 있으므로, 별도의 스크롤 컨테이너를 만들지 않고도 무한스크롤 UX를 구현할 수 있음
- **접근성 측면에서 유리**: 윈도우 스크롤을 그대로 사용하면 포커스 이동, 스크린리더의 문서 탐색 등 기본 브라우저/보조기기 동작과 충돌할 여지가 줄어듦

### 코드 위치

- `(features)` 레이아웃: `src/app/(features)/layout.tsx`
- 무한스크롤 페이지: `src/app/(features)/list-infinite/page.tsx`

---

## 결정 5: 컴포넌트 구조 및 상태 책임 분리

**날짜**: 2025-12-15

### 컨텍스트

무한스크롤 피쳐는 페이지(Server Component), 데이터/스크롤 상태를 관리하는 컨테이너(Client Component), 그리고 실제 UI를 그리는 View 컴포넌트로 나눌 수 있음.  
페이지네이션 피쳐에서와 마찬가지로, 상태와 UI 책임을 분리해 재사용성과 가독성을 확보할 필요가 있음.

### 결정

**페이지(Server) → 컨테이너(Client) → View(공용 컴포넌트) 구조를 사용해 역할을 분리함**

1. **페이지(Server Component)**
   - `src/app/(features)/list-infinite/page.tsx`
   - SEO 설정 및 페이지 타이틀 등 정적인 정보만 담당함
   - 본문에서는 무한스크롤 컨테이너를 렌더링하고, 필요 시 `ErrorBoundary`/`AsyncBoundary`로 감쌈

2. **컨테이너(Client Component)**
   - `src/app/(features)/list-infinite/components/InfiniteListContainer.tsx`
   - React Query `useSuspenseInfiniteQuery`를 사용해 페이지 단위 데이터를 로드하고, `pages.flatMap((page) => page.data)`로 평탄화해 `PostList`에 전달함
   - `InfiniteScrollWrapper`에 무한스크롤 관련 상태(`hasNextPage`, `isFetchingNextPage`, `isError`, `fetchNextPage`)와 `loadingFallback`을 전달함

3. **무한스크롤 래퍼 컴포넌트**
   - `src/app/(features)/list-infinite/components/InfiniteScrollWrapper.tsx`
   - IntersectionObserver를 사용해 하단 sentinel 요소를 감지하고, 자동 로드를 트리거함
   - 하단 상태 UI를 조건부 렌더링으로 관리:
     - 에러 상태: 재시도 버튼 표시
     - 마지막 페이지: "더 이상 불러올 게시글이 없습니다." 메시지 표시
     - 로딩 중: `loadingFallback` prop으로 받은 로딩 인디케이터 표시
   - `role="status"`, `aria-live="polite"`를 적용해 접근성을 고려함

4. **View 컴포넌트**
   - 공용 Post UI 컴포넌트 재사용
     - 리스트: `src/shared/components/post/PostList.tsx`
     - 아이템: `src/shared/components/post/PostItem.tsx`
     - 스켈레톤: `src/shared/components/post/PostListSkeleton.tsx`
   - 무한스크롤 전용 스타일/레이아웃은 `InfiniteScrollWrapper` 내부에서 처리함

5. **에러 처리 전략**
   - 초기 로드 에러: `AsyncBoundary`의 `ErrorBoundary`가 처리함
   - 추가 로드(`fetchNextPage`) 에러: `InfiniteScrollWrapper` 내부에서 `isError` 상태를 확인해 하단에 재시도 버튼을 표시하고, 사용자가 버튼을 클릭하면 `onLoadMore`(즉, `fetchNextPage`)를 재호출함

### 근거

- **역할 분리로 인한 가독성 향상**: 페이지는 라우팅/SEO, 컨테이너는 데이터·스크롤 상태, View는 실제 렌더링만 담당해 각 파일의 책임이 명확해짐
- **재사용성 확보**: Post 리스트/아이템/스켈레톤은 페이지네이션과 무한스크롤에서 공용으로 사용하고, 데이터/스크롤 로직만 각 피쳐 컨테이너에서 다르게 가져갈 수 있음
- **테스트 용이성**: 컨테이너를 기준으로 무한스크롤 동작을 집중적으로 테스트할 수 있고, View 컴포넌트는 단순 렌더링 테스트에 집중할 수 있음
- **아키텍처 결정과 일관성 유지**: `02-architecture.md`에서 정의한 “Client Components에서 React Query 사용, 피쳐별 hooks/api 분리” 원칙과 맞게, 무한스크롤 전용 훅/컴포넌트 위치가 자연스럽게 정리됨

### 코드 위치

- 페이지(Server): `src/app/(features)/list-infinite/page.tsx`
- 컨테이너(Client): `src/app/(features)/list-infinite/components/InfiniteListContainer.tsx`
- 무한스크롤 래퍼: `src/app/(features)/list-infinite/components/InfiniteScrollWrapper.tsx`
- 무한스크롤 전용 훅: `src/app/(features)/list-infinite/hooks/useInfinitePostList.ts`
- API 래퍼: `src/app/(features)/list-infinite/api/posts.ts`
- 공용 Post 컴포넌트:
  - 리스트: `src/shared/components/post/PostList.tsx`
  - 아이템: `src/shared/components/post/PostItem.tsx`
  - 스켈레톤: `src/shared/components/post/PostListSkeleton.tsx`

---

## 결정 6: 가상화 및 프리패치 사용 여부

**날짜**: 2025-12-15

### 컨텍스트

무한스크롤 구현 시, 많은 아이템을 렌더링할 때 성능 최적화를 위해 가상화 라이브러리(예: `react-window`, `react-virtualized`)를 사용할 수 있음.  
또한 사용자가 도달하기 전에 미리 다음 페이지를 불러오는 프리패치 전략을 사용할 수도 있음.  
이번 과제는 더미 데이터 기반의 비교적 작은 규모 리스트를 대상으로 하며, 패턴 학습과 기본적인 UX 구현이 목표임.

### 결정

**가상화 라이브러리와 공격적인 프리패치 전략은 사용하지 않고, 적절한 `limit` 설정과 React Query 기본 캐싱만 사용함**

1. **가상화**
   - `react-window`, `react-virtualized` 등 가상화 라이브러리는 도입하지 않음
   - DOM에는 현재까지 불러온 아이템을 그대로 렌더링함

2. **프리패치**
   - 사용자가 sentinel 근처까지 스크롤했을 때만 다음 페이지를 요청함
   - 사용자가 아직 스크롤하지 않은 앞 구간을 미리 여러 페이지까지 당겨오는 프리패치는 사용하지 않음

### 근거

- **과제 스코프에 적합한 단순성**: 이번 과제에서 사용하는 데이터 양과 UI 복잡도는 가상화가 필요한 수준이 아니며, 오히려 코드 복잡도만 늘릴 가능성이 큼
- **디버깅 및 학습 용이성**: DOM에 실제로 어떤 아이템이 렌더링되어 있는지 바로 확인할 수 있어, 무한스크롤 동작을 이해하고 디버깅하기 쉬움
- **예측 가능한 로딩 경험**: 사용자가 실제로 리스트 하단에 도달했을 때만 로딩이 발생하므로, 사용자가 의도하지 않은 시점에 백그라운드에서 과도한 데이터가 로드되는 상황을 피할 수 있음

### 대안 검토

- **대안 1: 가상화 라이브러리 도입**
  - 장점: 매우 긴 리스트에서도 렌더링 성능을 크게 개선할 수 있음
  - 단점: 스크롤 위치 계산과 아이템 높이 관리 등 추가 고려사항이 늘어나고, 이번 과제의 데이터 규모에서는 체감 이득이 크지 않음. 학습 목표 대비 복잡도가 과도해 제외함

- **대안 2: 적극적인 프리패치 전략**
  - 장점: 사용자가 리스트 하단에 도달하기 전에 이미 다음 데이터를 받아두어 체감 속도를 높일 수 있음
  - 단점: 불필요한 네트워크 사용과 상태 관리 복잡도가 늘어나며, 사용자가 실제로 그 지점까지 스크롤하지 않을 수도 있음. 이번 과제에서는 단순한 “하단 도달 시 로드” 패턴만 사용하기로 함

---

## 결정 7: 접근성(A11y) 기준

**날짜**: 2025-12-15

### 컨텍스트

무한스크롤은 스크롤 위치에 따라 콘텐츠가 동적으로 추가되기 때문에, 접근성(A11y) 측면에서 추가적인 고려가 필요함.  
특히 하단 로딩/에러/마지막 상태에 대한 피드백 방식과 포커스 이동/스크롤 제어 방식에 대한 기준을 정해야 함.

### 결정

**하단 상태 영역을 중심으로 최소한의 피드백을 제공하되, 포커스와 스크롤은 사용자가 직접 제어하도록 함**

1. **상태 피드백**
   - 하단 상태 영역(로딩/에러/마지막)은 `role="status"`, `aria-live="polite"`를 사용해 상태 변화를 스크린리더에 전달함
   - “마지막입니다” 메시지는 시각적으로만이 아니라, 텍스트로도 명확히 제공해 스크린리더 사용자가 리스트의 끝을 인지할 수 있도록 함

2. **포커스 및 스크롤 제어**
   - 추가 로드 중에도 포커스를 강제로 이동시키지 않고, 사용자가 스크롤/탐색 흐름을 직접 제어하도록 함
   - 자동 스크롤 이동은 사용하지 않으며, 사용자가 뒤로 가기 등 네비게이션 동작으로 위치를 스스로 관리할 수 있도록 함

### 근거

- **접근성 유지**: 하단 상태 영역만으로도 로딩/에러/종료 상태를 알 수 있어, 시각·비시각 사용자 모두 현재 리스트 상태를 인지할 수 있음
- **사용자 제어권 보장**: 스크롤이나 포커스를 자동으로 건드리지 않아, 사용자가 “어디까지 봤는지”를 스스로 관리할 수 있음

---

## 결정 8: SEO 관점에서의 기준

**날짜**: 2025-12-15

### 컨텍스트

무한스크롤은 스크롤 이후에야 추가 콘텐츠가 로드되기 때문에, 검색 엔진이 모든 콘텐츠를 인덱싱하기 어려운 특성이 있음.  
이번 과제에서 무한스크롤 페이지를 SEO 관점에서 어느 정도 수준까지 고려할 것인지 기준을 정해야 함.

### 결정

**무한스크롤 페이지는 일반적인 메타 정보 설정과 초기 구간 SSR 정도만 고려하고, 추가 구간까지의 완전한 인덱싱은 기대하지 않음**

1. **메타 정보**
   - 일반 Next.js 페이지와 동일하게 타이틀, 설명 등 기본 메타 정보를 설정함

2. **인덱싱 범위**
   - 초기 로드 구간(첫 페이지 데이터)이 SSR로 렌더링되는 수준이면 충분하다고 보고, 스크롤 이후 로드되는 모든 구간까지의 완전한 인덱싱은 필수 요구사항으로 보지 않음

### 근거

- **무한스크롤 특성 반영**: 스크롤 이후에야 로드되는 콘텐츠까지 완전히 인덱싱하기는 구조적으로 어려우며, 이를 위해 별도의 복잡한 SSR/프리렌더링 전략을 도입하는 것은 이번 과제 범위를 벗어남
- **과제 목적과의 정합성**: 이번 피쳐의 핵심 목표는 무한스크롤 UX와 패턴 학습에 있으며, SEO 극대화는 별도의 과제로 다루는 것이 적절하다고 판단함
